#!/usr/bin/with-contenv bash
# shellcheck shell=bash
# 修复版本：解决首次启动时requirements.txt变化检测问题

# 使用递归函数比较两个目录
function compare {
    for entry in "$1"/*; do
        if [[ -d "$entry" ]]; then
            if [[ ! -d "$2/$(basename "$entry")" ]]; then
                mkdir "$2/$(basename "$entry")"
                echo "创建 $2/$(basename "$entry") 文件夹"
            fi
            compare "$entry" "$2/$(basename "$entry")"
        elif [[ -f "$entry" ]]; then
            if [[ ! -f "$2/$(basename "$entry")" ]]; then
                cp "$entry" "$2/$(basename "$entry")"
                echo "创建 $2/$(basename "$entry") 文件"
            elif [[ "$(diff "$entry" "$2/$(basename "$entry")")" ]]; then
                cp "$entry" "$2/$(basename "$entry")"
                echo "更新 $2/$(basename "$entry") 文件"
            fi
        fi
    done
}

# 智能多源切换函数
function try_mirrors_with_fallback {
    local mirror_type="$1"
    local timeout=10
    
    if [ "$mirror_type" = "alpine" ]; then
        local mirrors=(
            "mirrors.aliyun.com"
            "mirrors.cloud.tencent.com"
            "mirror.lzu.edu.cn"
            "mirrors.163.com"
            "repo.huaweicloud.com"
            "mirrors.tuna.tsinghua.edu.cn"
            "mirrors.ustc.edu.cn"
        )
        
        for mirror in "${mirrors[@]}"; do
            echo "尝试Alpine镜像源: $mirror"
            if timeout $timeout wget --spider --quiet "https://$mirror/alpine/" 2>/dev/null; then
                echo "Alpine镜像源 $mirror 连接成功"
                export ALPINE_MIRROR="$mirror"
                return 0
            else
                echo "Alpine镜像源 $mirror 连接失败或超时"
            fi
        done
        
        echo "所有Alpine镜像源都无法连接，使用默认源"
        export ALPINE_MIRROR="dl-cdn.alpinelinux.org"
        return 1
        
    elif [ "$mirror_type" = "pypi" ]; then
        local mirrors=(
            "https://pip.nastool.work/simple/"
            "https://mirrors.aliyun.com/pypi/simple/"
            "https://mirrors.cloud.tencent.com/pypi/simple/"
            "https://mirrors.163.com/pypi/simple/"
            "https://mirrors.tuna.tsinghua.edu.cn/pypi/web/simple/"
        )
        
        for mirror in "${mirrors[@]}"; do
            echo "尝试PyPI镜像源: $mirror"
            # 提取主机名用于trusted-host参数
            host=$(echo "$mirror" | sed 's|https\?://||' | sed 's|/.*||')
            if timeout 10 pip index versions --index-url "$mirror" --trusted-host "$host" requests > /dev/null 2>&1; then
                echo "PyPI镜像源 $mirror 连接成功"
                export PYPI_MIRROR="$mirror"
                return 0
            else
                echo "PyPI镜像源 $mirror 连接失败或超时"
            fi
        done
        
        echo "所有PyPI镜像源都无法连接，使用默认源"
        export PYPI_MIRROR="https://pypi.org/simple/"
        return 1
    fi
}

# 更换国内软件源
function package_cn {
    # 忽略环境变量，重新智能选择最佳Alpine镜像源
    unset ALPINE_MIRROR
    try_mirrors_with_fallback "alpine"
    
    # 备份原始文件
    # 增加判断：如果dl-cdn.alpinelinux.org在/etc/apk/repositories中则
    if grep -q "dl-cdn.alpinelinux.org" /etc/apk/repositories; then
        cp /etc/apk/repositories /etc/apk/repositories.bak
    fi
    
    # 如果动态检测成功，使用检测到的镜像源替换官方源
    if [ -n "${ALPINE_MIRROR}" ]; then
        cp /etc/apk/repositories.bak /etc/apk/repositories
        sed -i "s/dl-cdn.alpinelinux.org/${ALPINE_MIRROR}/g" /etc/apk/repositories
    fi
    # 如果动态检测失败，直接使用原始文件（已经是官方源）
    apk update -f 
    if [ $? -ne 0 ]; then
        echo "无法更换软件源，请更新镜像！"
        cp /etc/apk/repositories.bak /etc/apk/repositories
    fi
}



# 软件包更新 - Alpine Linux
function package_update {
    hash_old=$(cat /tmp/package_list.txt.sha256sum)
    hash_new=$(sha256sum package_list.txt)
    if [ "${hash_old}" != "${hash_new}" ]; then
        echo "检测到package_list.txt有变化，更新软件包..."
        if [ "${NASTOOL_CN_UPDATE}" = "true" ]; then
            package_cn
        fi
        apk add --no-cache $(echo $(cat package_list.txt)) 
        if [ $? -ne 0 ]; then
            echo "无法更新软件包，请更新镜像！"
            echo "软件包更新失败，保持原有sha256sum以便下次重试"
        else
            echo "软件包安装成功"
            # 只有在安装成功时才更新sha256sum
            sha256sum package_list.txt > /tmp/package_list.txt.sha256sum
        fi
    fi
}

# python库更新 - 修复版本
function requirements_update {
    hash_old=$(cat /tmp/requirements.txt.sha256sum)
    hash_new=$(sha256sum requirements.txt)
    if [ "${hash_old}" != "${hash_new}" ]; then
        echo "检测到requirements.txt有变化，重新安装依赖（安装需要联网，可能需要5-30分钟），请耐心等待..."
        install_success=false
        if [ "${NASTOOL_CN_UPDATE}" = "true" ]; then
            # 先测试PyPI镜像源，避免重复测试Alpine源
            unset PYPI_MIRROR
            try_mirrors_with_fallback "pypi"
            pip install --upgrade pip setuptools wheel -i "${PYPI_MIRROR}" -q
            pip install -r requirements.txt -i "${PYPI_MIRROR}" -q
        else
            pip install --upgrade pip setuptools wheel -q
            pip install -r requirements.txt -q
        fi
        if [ $? -ne 0 ]; then
            echo "依赖安装失败！未进行通用系统包更新，可能因缺少系统包或网络问题导致。请手动检查系统包或网络环境后重试。"
        else
            install_success=true
            echo "===========依赖安装成功==========="
        fi
        
        # 只有在安装成功时才更新sha256sum
        if [ "$install_success" = "true" ]; then
            sha256sum requirements.txt > /tmp/requirements.txt.sha256sum
        fi
    else
        echo "requirements.txt没有变化，跳过依赖安装"
    fi
}

if [ "${NASTOOL_AUTO_UPDATE}" != "true" ]; then  
    while true; do  
        echo "自动升级已关闭，你不是在--爱上NAS爱上家--淘宝店铺购买的，请立即退款，避免上当受骗，减少损失！！！"  
        sleep 1
    done 
fi  
    
if [[ ! "${REPO_URL}" == *"https://gitee.com/nobody114"* ]]; then  
    while true; do  
        echo "非法更新地址：你不是在--爱上NAS爱上家--淘宝店铺购买的，请立即退款，避免上当受骗，减少损失！！！"
        sleep 1
    done  
fi 

# third_party更新 - 修复版本
function third_party_update {
    hash_old=$(cat /tmp/third_party.txt.sha256sum)
    hash_new=$(sha256sum third_party.txt)
    if [ "${hash_old}" != "${hash_new}" ]; then
        echo "检测到third_party.txt有变化，更新第三方组件..."
        rm -f .git/*.lock .git/refs/heads/*.lock 2>/dev/null
        git submodule update --init --recursive
        if [ $? -ne 0 ]; then
            echo "无法更新第三方组件，请更新镜像！"
            echo "第三方组件更新失败，保持原有sha256sum以便下次重试"
            exit 1
        else
            echo "第三方组件安装成功"
            # 只有在更新成功时才更新sha256sum
            sha256sum third_party.txt > /tmp/third_party.txt.sha256sum
        fi
    else
        echo "third_party.txt没有变化，跳过第三方组件更新"
    fi
}

# 修复版本的主函数
function __main {
    cd ${WORKDIR}

    # 自动更新
    if [ "${NASTOOL_AUTO_UPDATE}" = "true" ]; then
        echo "更新主程序（安装需要联网，可能需要5-30分钟），请耐心等待..."
        echo "长时间更新不了是网络问题，尝试重启光猫、重启路由器、重启设备，更换宽带"
        git remote set-url origin "${REPO_URL}" &> /dev/null
        echo "windows/" > .gitignore
        
        # 更新分支
        if [[ "${NASTOOL_VERSION}" == "dev" ]]; then
            branch="dev"
        else
            branch="master"
        fi

        # 在git操作之前，先为首次运行创建基于镜像原始文件的sha256sum
        if [ ! -f /tmp/package_list.txt.sha256sum ]; then
            echo "首次运行，基于镜像原始文件创建package_list.txt基准哈希"
            sha256sum package_list.txt > /tmp/package_list.txt.sha256sum
        fi
        
        if [ ! -f /tmp/requirements.txt.sha256sum ]; then
            echo "首次运行，基于镜像原始文件创建requirements.txt基准哈希"
            sha256sum requirements.txt > /tmp/requirements.txt.sha256sum
        fi
        
        if [ ! -f /tmp/third_party.txt.sha256sum ]; then
            echo "首次运行，基于镜像原始文件创建third_party.txt基准哈希"
            sha256sum third_party.txt > /tmp/third_party.txt.sha256sum
        fi

        # 执行git操作（清理锁文件后）
        rm -f .git/*.lock .git/refs/heads/*.lock 2>/dev/null
        git clean -dffx
        git fetch --depth 1 origin ${branch}
        git reset --hard origin/${branch}

        if [ $? -eq 0 ]; then
            echo "主程序更新成功"
            
            # 服务脚本更新
            compare "/nas-tools/docker/rootfs/etc" "/etc"
            chmod -R +x \
                /etc/cont-init.d \
                /etc/services.d
            
            # 系统软件包更新
            package_update
            
            # Python依赖包更新
            requirements_update
            
            # third_party 更新
            third_party_update
        else
            echo "更新失败，继续使用旧的程序来启动..."
        fi
    else
        echo "程序自动升级已关闭，如需自动升级请在创建容器时设置环境变量：NASTOOL_AUTO_UPDATE=true"
    fi
}

__main 2>&1 | sed "s#^#cont-init: info: $(realpath $0): &#g"