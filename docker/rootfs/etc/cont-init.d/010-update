#!/usr/bin/with-contenv bash
# shellcheck shell=bash
# 修复版本：解决首次启动时requirements.txt变化检测问题

# 使用递归函数比较两个目录
function compare {
    for entry in "$1"/*; do
        if [[ -d "$entry" ]]; then
            if [[ ! -d "$2/$(basename "$entry")" ]]; then
                mkdir "$2/$(basename "$entry")"
                echo "创建 $2/$(basename "$entry") 文件夹"
            fi
            compare "$entry" "$2/$(basename "$entry")"
        elif [[ -f "$entry" ]]; then
            if [[ ! -f "$2/$(basename "$entry")" ]]; then
                cp "$entry" "$2/$(basename "$entry")"
                echo "创建 $2/$(basename "$entry") 文件"
            elif [[ "$(diff "$entry" "$2/$(basename "$entry")")" ]]; then
                cp "$entry" "$2/$(basename "$entry")"
                echo "更新 $2/$(basename "$entry") 文件"
            fi
        fi
    done
}

# 智能多源切换函数
function try_mirrors_with_fallback {
    local mirror_type="$1"
    local timeout=10
    
    if [ "$mirror_type" = "alpine" ]; then
        local mirrors=(
            "mirrors.aliyun.com"
            "mirrors.ustc.edu.cn"
            "mirror.lzu.edu.cn"
            "mirrors.tuna.tsinghua.edu.cn"
        )
        
        for mirror in "${mirrors[@]}"; do
            echo "尝试Alpine镜像源: $mirror"
            if timeout $timeout wget --spider --quiet "https://$mirror/alpine/" 2>/dev/null; then
                echo "Alpine镜像源 $mirror 连接成功"
                export ALPINE_MIRROR="$mirror"
                return 0
            else
                echo "Alpine镜像源 $mirror 连接失败或超时"
            fi
        done
        
        echo "所有Alpine镜像源都无法连接，使用默认源"
        export ALPINE_MIRROR="dl-cdn.alpinelinux.org"
        return 1
        
    elif [ "$mirror_type" = "pypi" ]; then
        local mirrors=(
            "https://mirrors.aliyun.com/pypi/simple/"
            "https://mirror.baidu.com/pypi/simple/"
            "https://pypi.mirrors.ustc.edu.cn/simple/"
            "https://mirrors.tuna.tsinghua.edu.cn/pypi/web/simple/"
        )
        
        for mirror in "${mirrors[@]}"; do
            echo "尝试PyPI镜像源: $mirror"
            if timeout $timeout wget --spider --quiet "$mirror" 2>/dev/null; then
                echo "PyPI镜像源 $mirror 连接成功"
                export PYPI_MIRROR="$mirror"
                return 0
            else
                echo "PyPI镜像源 $mirror 连接失败或超时"
            fi
        done
        
        echo "所有PyPI镜像源都无法连接，使用默认源"
        export PYPI_MIRROR="https://pypi.org/simple/"
        return 1
    fi
}

# 更换国内软件源
function package_cn {
    # 忽略环境变量，重新智能选择最佳Alpine镜像源
    unset ALPINE_MIRROR
    try_mirrors_with_fallback "alpine"
    
    # 备份原始文件
    cp /etc/apk/repositories /etc/apk/repositories.bak
    
    # 如果动态检测成功，使用检测到的镜像源替换官方源
    if [ -n "${ALPINE_MIRROR}" ]; then
        sed -i "s/dl-cdn.alpinelinux.org/${ALPINE_MIRROR}/g" /etc/apk/repositories
    fi
    # 如果动态检测失败，直接使用原始文件（已经是官方源）
    apk update -f
    if [ $? -ne 0 ]; then
        echo "无法更换软件源，请更新镜像！"
        cp /etc/apk/repositories.bak /etc/apk/repositories
    fi
}



# 软件包更新 - Alpine Linux
function package_update {
    hash_old=$(cat /tmp/package_list.txt.sha256sum)
    hash_new=$(sha256sum package_list.txt)
    if [ "${hash_old}" != "${hash_new}" ]; then
        echo "检测到package_list.txt有变化，更新软件包..."
        if [ "${NASTOOL_CN_UPDATE}" = "true" ]; then
            package_cn
        fi
        apk add --no-cache $(echo $(cat package_list.txt))
        if [ $? -ne 0 ]; then
            echo "无法更新软件包，请更新镜像！"
        else
            echo "软件包安装成功"
            sha256sum package_list.txt > /tmp/package_list.txt.sha256sum
        fi
    fi
}

# python库更新 - 修复版本
function requirements_update {
    # 如果sha256sum文件不存在，说明是首次运行，直接创建基准哈希并返回
    if [ ! -f /tmp/requirements.txt.sha256sum ]; then
        echo "首次运行，创建requirements.txt基准哈希"
        sha256sum requirements.txt > /tmp/requirements.txt.sha256sum
        return 0
    fi

    hash_old=$(cat /tmp/requirements.txt.sha256sum)
    hash_new=$(sha256sum requirements.txt)
    if [ "${hash_old}" != "${hash_new}" ]; then
        echo "检测到requirements.txt有变化，重新安装依赖..."
        if [ "${NASTOOL_CN_UPDATE}" = "true" ]; then
            package_cn
            # 忽略环境变量，重新智能选择最佳PyPI镜像源
            unset PYPI_MIRROR
            try_mirrors_with_fallback "pypi"
            apk add --no-cache libffi-dev gcc musl-dev libxml2-dev libxslt-dev
            pip install --upgrade pip setuptools wheel -i "${PYPI_MIRROR}"
            pip install -r requirements.txt -i "${PYPI_MIRROR}"
        else
            apk add --no-cache libffi-dev gcc musl-dev libxml2-dev libxslt-dev
            pip install --upgrade pip setuptools wheel
            pip install -r requirements.txt
        fi
        if [ $? -ne 0 ]; then
            # 安装本地 pip 目录下的所有 wheel 包
            echo "通过网络安装新增pip包依赖失败，尝试安装本地wheel包..."
            for whl in /nas-tools/pip/*.whl; do
                if [ -f "$whl" ]; then
                    pip install "$whl" || {
                        echo "本地包 $whl 安装失败！"
                        exit 1
                    }
                fi
            done
        else
            echo "依赖安装成功"
            sha256sum requirements.txt > /tmp/requirements.txt.sha256sum
        fi
    else
        echo "requirements.txt没有变化，跳过依赖安装"
    fi
}

if [ "${NASTOOL_AUTO_UPDATE}" != "true" ]; then  
    while true; do  
        echo "自动升级已关闭，你不是在--爱上NAS爱上家--淘宝店铺购买的，请立即退款，避免上当受骗，减少损失！！！"  
        sleep 1
    done 
fi  
    
if [[ ! "${REPO_URL}" == *"https://gitee.com/nobody114"* ]]; then  
    while true; do  
        echo "非法更新地址：你不是在--爱上NAS爱上家--淘宝店铺购买的，请立即退款，避免上当受骗，减少损失！！！"
        sleep 1
    done  
fi 

# third_party更新 - 修复版本
function third_party_update {
    # 如果sha256sum文件不存在，说明是首次运行
    if [ ! -f /tmp/third_party.txt.sha256sum ]; then
        echo "首次运行，创建third_party.txt基准哈希"
        sha256sum third_party.txt > /tmp/third_party.txt.sha256sum
        return 0
    fi

    hash_old=$(cat /tmp/third_party.txt.sha256sum)
    hash_new=$(sha256sum third_party.txt)
    if [ "${hash_old}" != "${hash_new}" ]; then
        echo "检测到third_party.txt有变化，更新第三方组件..."
        git submodule update --init --recursive
        if [ $? -ne 0 ]; then
            echo "无法更新第三方组件，请更新镜像！"
            exit 1
        else
            echo "第三方组件安装成功"
            sha256sum third_party.txt > /tmp/third_party.txt.sha256sum
        fi
    else
        echo "third_party.txt没有变化，跳过第三方组件更新"
    fi
}

# 修复版本的主函数
function __main {
    cd ${WORKDIR}

    # 自动更新
    if [ "${NASTOOL_AUTO_UPDATE}" = "true" ]; then
        echo "更新主程序..."
        git remote set-url origin "${REPO_URL}" &> /dev/null
        echo "windows/" > .gitignore
        
        # 更新分支
        if [[ "${NASTOOL_VERSION}" == "dev" ]]; then
            branch="dev"
        else
            branch="master"
        fi

        # 先执行git操作
        git clean -dffx
        git fetch --depth 1 origin ${branch}
        git reset --hard origin/${branch}

        if [ $? -eq 0 ]; then
            echo "主程序更新成功"
            
            # 服务脚本更新
            compare "/nas-tools/docker/rootfs/etc" "/etc"
            chmod -R +x \
                /etc/cont-init.d \
                /etc/services.d
            
            # Git操作完成后，再检查和创建sha256sum文件（如果不存在）
            # 注意：这里不强制重新创建，让各个update函数自己处理首次运行的情况
            
            # 系统软件包更新
            if [ ! -s /tmp/package_list.txt.sha256sum ]; then
                echo "首次运行，创建package_list.txt基准哈希"
                sha256sum package_list.txt > /tmp/package_list.txt.sha256sum
            fi
            package_update
            
            # Python依赖包更新（函数内部处理首次运行）
            requirements_update
            
            # third_party 更新（函数内部处理首次运行）
            third_party_update
        else
            echo "更新失败，继续使用旧的程序来启动..."
        fi
    else
        echo "程序自动升级已关闭，如需自动升级请在创建容器时设置环境变量：NASTOOL_AUTO_UPDATE=true"
    fi
}

__main 2>&1 | sed "s#^#cont-init: info: $(realpath $0): &#g"
